<!DOCTYPE html>
<html lang="en" style="height: 100%;">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>常用國字標準字體筆劃 in Physijs</title>
        <link rel="stylesheet" href="../../css/demo.css" type="text/css" media="screen">
        <script src="../../js/jquery-1.9.1.min.js"></script>
        <script src="../../js/gl-matrix-min.js"></script>
        <script src="../../js/sax.js"></script>
        <script src="../../js/q.min.js"></script>
        <script src="../../js/utils.stroke-words.js"></script>
        <script src="../three-js/js/three.js"></script>
        <script src="../three-js/js/controls/OrbitControls.js"></script>
        <script src="js/physi.js"></script>
    </head>
    <body style="margin: 0; padding: 0; height: 100%;">
        <script>
          /**
           * play with Physijs
           */
          Physijs.scripts.worker = "js/physijs_worker.js";
          Physijs.scripts.ammo = "ammo.js";
          /**
           * initialize three.js
           */
          var $body = $("body");
          /* CSS3DRenderer doesnt work D: */
          //var renderer = new THREE.CSS3DRenderer();
          var renderer = new THREE.WebGLRenderer();
          renderer.setSize($body.width(), $body.height());
          renderer.shadowMapEnabled = true;
          renderer.shadowMapSoft = true;
          $body.append(renderer.domElement);

var controls;
          // scene
          var scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
          scene.setGravity(new THREE.Vector3(0, -1024, 0));
var i = 0;
          scene.addEventListener(
            "update",
            function() {
                scene.simulate(undefined, 2);
                controls.update();
             }
          );

// background
var geometry  = new THREE.SphereGeometry(8000, 32, 32);
// create the material, using a texture of startfield
var material  = new THREE.MeshBasicMaterial();
material.map   = THREE.ImageUtils.loadTexture('images/stars.jpg');
material.side  = THREE.BackSide;
// create the mesh based on geometry and material
scene.add(new THREE.Mesh(geometry, material));


          // camera
          var camera = new THREE.PerspectiveCamera(45, $body.width() / $body.height(), 1, 100000);
          camera.position.set(22000, 0, 5500);
          scene.add(camera);
          // lights
          scene.add(new THREE.AmbientLight(0x333333));
          var light = new THREE.DirectionalLight(0xFFFFFF);
          light.position = new THREE.Vector3(0, 3000, 3000);
          light.target.position.copy(scene.position);
          light.castShadow = true;
          light.shadowCameraLeft = -4000;
          light.shadowCameraRight = 4000;
          light.shadowCameraTop = 4000;
          light.shadowCameraBottom = -4000;
          light.shadowCameraNear = 20;
          light.shadowCameraFar = 10000;
          light.shadowMapWidth = light.shadowMapHeight = 512;
          scene.add(light);
          // material
          var materialFront = new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture( 'images/wood.jpg' ),
            color: 0x999999,
            ambient: 0xF0F0F0
          });
          var material = new Physijs.createMaterial(materialFront, 8, 0.4);

        var block_material = Physijs.createMaterial(
                new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/plywood.jpg' ), ambient: 0xFF9999 }),
                0.9, // medium friction
                0.5 // medium restitution
        );
        block_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
        block_material.map.repeat.set( 1, .5 );


          // ground
          var ground = new Physijs.BoxMesh(
            new THREE.CubeGeometry(10000, 500, 10000),
            material,
            0
          );
          ground.position.set(0, -1075, 0);
          ground.rotation.set(0, 45 * Math.PI / 180, 0);
          ground.receiveShadow = true;
          scene.add(ground);

          /* get strokes */
          var i, j;
          var data = new WordStroker.utils.StrokeData({url: "../../json/"})
          var c    = WordStroker.utils.sortSurrogates("萌");
          var cp   = c[0].cp
          data.get(cp).then(function(strokes) {
            var groups = []
            var shapes = []
            for (i in strokes) {
              var stroke = strokes[i];
              var shape = new THREE.Shape();
              for (j in stroke.outline) {
                var cmd = stroke.outline[j];
                switch (cmd.type) {
                  case "M":
                    shape.moveTo(cmd.x, -cmd.y);
                    break;
                  case "L":
                    shape.lineTo(cmd.x, -cmd.y);
                    break;
                  case "Q":
                    shape.quadraticCurveTo(
                      cmd.begin.x, -cmd.begin.y,
                      cmd.end.x, -cmd.end.y
                    );
                    break;
                  case "C":
                    shape.bezierCurveTo(
                      cmd.begin.x, -cmd.begin.y,
                      cmd.mid.x, -cmd.mid.y,
                      cmd.end.x, -cmd.end.y
                    );
                    break;
                }
              }
              shapes.push(shape);
              i = parseInt(i, 10);
              switch (i) {
                case 1: case 3: case 7: case 11:
                  j = groups.length;
                  break;
                default:
                  j = null;
              }
              if (j !== null) {
                groups[j] = shapes;
                shapes = [];
              }
            }
            // geometry
            var extrusionSettings = {
              amount: 100,
              bevelEnabled: false,
              material: block_material,
              extrudeMaterial: block_material
            };
            //var object = new THREE.Object3D();
            /* so it's possible to build a geometry from many strokes */
var doAddChar = function() {
              var randX = Math.random() * 5000 - 2500;
              var randY = Math.random() * 500 - 250;
              var randZ = Math.round(Math.random() * 5);
              var randA = Math.random() * 90 - 45;
            for (i in groups) {
              //i = parseInt(i, 10);
              var geometry = new THREE.ExtrudeGeometry(groups[i], extrusionSettings);
              var mesh = new Physijs.ConvexMesh(geometry, block_material, 9);
              mesh.position.set(-1075 + randX, 1175 + randY, randZ);
              mesh.rotation.set(0, (randA + 45) * Math.PI / 180, 0);
              mesh.castShadow = true;
              mesh.receiveShadow = true;
              scene.add(mesh);
            }
};
doAddChar();
doAddChar();
doAddChar();
            // object
            camera.lookAt(new THREE.Vector3(0, -250, 0));
            //scene.add(object);
            // render
            var render = function() {
              requestAnimationFrame(render);
              renderer.render(scene, camera);
            };

controls = new THREE.OrbitControls( camera );

            requestAnimationFrame(render);
            scene.simulate();
$('body').click( function () {
doAddChar();
});
          });
        </script>
    </body>
</html>
